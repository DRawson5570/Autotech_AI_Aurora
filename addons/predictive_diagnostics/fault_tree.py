"""
Fault Tree Data Structures and Generation

Fault trees represent all the ways a vehicle system can fail.
They are generated by:
1. Getting wiring diagram from Mitchell (learning phase)
2. Extracting components and their connections
3. Applying failure taxonomy to each component
4. Adding TSB-based known issues with elevated probability
5. Computing cascading effects based on circuit topology

At runtime, the fault tree is used to:
1. Match symptoms to potential faults
2. Calculate probabilities using Bayesian inference
3. Recommend discriminating diagnostic tests
"""

from typing import Dict, List, Optional, Set, Tuple, Any
from dataclasses import dataclass, field
from datetime import datetime
import json
import hashlib

from .taxonomy import (
    ComponentType, 
    FailureMode, 
    FAILURE_TAXONOMY, 
    identify_component_type,
    get_failure_modes_for_component
)
from .signatures import (
    FailureSignature, 
    FAILURE_SIGNATURES, 
    substitute_component,
    get_signature
)


@dataclass
class Component:
    """A component extracted from a wiring diagram."""
    id: str                      # Unique identifier (e.g., "M12", "K15", "S22")
    name: str                    # Full name (e.g., "Coolant Pump Motor")
    component_type: ComponentType
    location: str = ""           # Physical location
    specifications: Dict[str, Any] = field(default_factory=dict)
    connected_to: List[str] = field(default_factory=list)  # IDs of connected components
    circuit_id: str = ""         # Which circuit it belongs to
    
    def __hash__(self):
        return hash(self.id)


@dataclass
class FaultNode:
    """A node in the fault tree representing a potential failure."""
    id: str                      # Unique identifier
    component: Component         # The component that fails
    failure_mode: FailureMode    # How it fails
    signature: Optional[FailureSignature] = None  # Observable pattern
    
    # Probability
    prior_probability: float = 0.05  # Base probability
    tsb_reference: Optional[str] = None
    tsb_boost: float = 1.0       # Multiplier if TSB applies (e.g., 3.0)
    
    # Diagnostic information
    diagnostic_test: str = ""
    repair_action: str = ""
    repair_time_hours: Optional[float] = None
    parts_cost: Optional[float] = None
    
    # Cascading effects
    causes: List[str] = field(default_factory=list)      # Fault IDs that can cause this
    effects: List[str] = field(default_factory=list)     # Fault IDs this can cause
    
    @property
    def effective_probability(self) -> float:
        """Get probability including TSB boost."""
        return min(1.0, self.prior_probability * self.tsb_boost)
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            "id": self.id,
            "component_id": self.component.id,
            "component_name": self.component.name,
            "component_type": self.component.component_type.value,
            "failure_mode": self.failure_mode.id,
            "failure_mode_name": self.failure_mode.name,
            "prior_probability": self.prior_probability,
            "effective_probability": self.effective_probability,
            "tsb_reference": self.tsb_reference,
            "diagnostic_test": self.diagnostic_test or self.failure_mode.diagnostic_approach,
            "repair_action": self.repair_action,
            "causes": self.causes,
            "effects": self.effects,
        }


@dataclass
class FaultTree:
    """Complete fault tree for a vehicle system."""
    vehicle_year: int
    vehicle_make: str
    vehicle_model: str
    vehicle_engine: Optional[str]
    system: str                  # e.g., "Cooling System", "Fuel System"
    
    components: Dict[str, Component] = field(default_factory=dict)
    fault_nodes: Dict[str, FaultNode] = field(default_factory=dict)
    
    created_at: datetime = field(default_factory=datetime.now)
    source: str = "generated"    # "generated", "cached", "manual"
    mitchell_data_hash: Optional[str] = None  # Hash of source data for cache invalidation
    
    def add_component(self, component: Component) -> None:
        """Add a component to the tree."""
        self.components[component.id] = component
    
    def add_fault_node(self, node: FaultNode) -> None:
        """Add a fault node to the tree."""
        self.fault_nodes[node.id] = node
    
    def get_faults_for_component(self, component_id: str) -> List[FaultNode]:
        """Get all fault nodes for a specific component."""
        return [
            node for node in self.fault_nodes.values()
            if node.component.id == component_id
        ]
    
    def get_faults_by_probability(self, min_prob: float = 0.0) -> List[FaultNode]:
        """Get fault nodes sorted by probability."""
        nodes = [n for n in self.fault_nodes.values() if n.effective_probability >= min_prob]
        return sorted(nodes, key=lambda n: n.effective_probability, reverse=True)
    
    def get_tsb_related_faults(self) -> List[FaultNode]:
        """Get fault nodes that have TSB references."""
        return [n for n in self.fault_nodes.values() if n.tsb_reference]
    
    @property
    def vehicle_string(self) -> str:
        engine_str = f" {self.vehicle_engine}" if self.vehicle_engine else ""
        return f"{self.vehicle_year} {self.vehicle_make} {self.vehicle_model}{engine_str}"
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            "vehicle": {
                "year": self.vehicle_year,
                "make": self.vehicle_make,
                "model": self.vehicle_model,
                "engine": self.vehicle_engine,
            },
            "system": self.system,
            "created_at": self.created_at.isoformat(),
            "source": self.source,
            "components": {
                cid: {
                    "id": c.id,
                    "name": c.name,
                    "type": c.component_type.value,
                    "location": c.location,
                    "connected_to": c.connected_to,
                }
                for cid, c in self.components.items()
            },
            "fault_nodes": {
                nid: node.to_dict()
                for nid, node in self.fault_nodes.items()
            },
        }
    
    def to_json(self, indent: int = 2) -> str:
        """Serialize to JSON."""
        return json.dumps(self.to_dict(), indent=indent)
    
    @classmethod
    def from_dict(cls, data: Dict) -> "FaultTree":
        """Create from dictionary."""
        tree = cls(
            vehicle_year=data["vehicle"]["year"],
            vehicle_make=data["vehicle"]["make"],
            vehicle_model=data["vehicle"]["model"],
            vehicle_engine=data["vehicle"].get("engine"),
            system=data["system"],
            source=data.get("source", "loaded"),
        )
        
        # Reconstruct components
        for cid, cdata in data.get("components", {}).items():
            comp = Component(
                id=cdata["id"],
                name=cdata["name"],
                component_type=ComponentType(cdata["type"]),
                location=cdata.get("location", ""),
                connected_to=cdata.get("connected_to", []),
            )
            tree.add_component(comp)
        
        # Note: Full reconstruction of fault nodes requires failure taxonomy
        # This is a simplified reconstruction
        
        return tree


class FaultTreeGenerator:
    """
    Generates fault trees from vehicle-specific data.
    
    LEARNING PHASE ONLY - this uses Mitchell data extraction.
    The generated fault trees are saved and used at runtime without Mitchell.
    """
    
    def __init__(self):
        self.taxonomy = FAILURE_TAXONOMY
        self.signatures = FAILURE_SIGNATURES
    
    def generate_from_components(
        self,
        vehicle_year: int,
        vehicle_make: str,
        vehicle_model: str,
        vehicle_engine: Optional[str],
        system: str,
        components: List[Dict[str, Any]],
        tsbs: List[Dict[str, Any]] = None,
    ) -> FaultTree:
        """
        Generate a fault tree from extracted component data.
        
        Args:
            vehicle_year, make, model, engine: Vehicle identification
            system: System name (e.g., "Cooling System")
            components: List of component dicts with id, name, type, specs, connections
            tsbs: Optional list of TSB dicts with related components
            
        Returns:
            FaultTree with all potential faults enumerated
        """
        tree = FaultTree(
            vehicle_year=vehicle_year,
            vehicle_make=vehicle_make,
            vehicle_model=vehicle_model,
            vehicle_engine=vehicle_engine,
            system=system,
            source="generated",
        )
        
        # Build TSB lookup for probability boosting
        tsb_lookup = self._build_tsb_lookup(tsbs or [])
        
        # Process each component
        for comp_data in components:
            # Create component
            comp_type = comp_data.get("type")
            if isinstance(comp_type, str):
                try:
                    comp_type = ComponentType(comp_type)
                except ValueError:
                    comp_type = identify_component_type(comp_data.get("name", ""))
            elif comp_type is None:
                comp_type = identify_component_type(comp_data.get("name", ""))
            
            component = Component(
                id=comp_data.get("id", f"C{len(tree.components)}"),
                name=comp_data.get("name", "Unknown"),
                component_type=comp_type,
                location=comp_data.get("location", ""),
                specifications=comp_data.get("specs", {}),
                connected_to=comp_data.get("connected_to", []),
                circuit_id=comp_data.get("circuit", ""),
            )
            tree.add_component(component)
            
            # Get applicable failure modes for this component type
            failure_modes = get_failure_modes_for_component(component.component_type)
            
            # Create fault node for each failure mode
            for mode_id, failure_mode in failure_modes.items():
                node_id = f"{component.id}_{mode_id}"
                
                # Get signature if available
                signature = get_signature(mode_id)
                if signature:
                    signature = substitute_component(signature, component.name)
                
                # Check for TSB boost
                tsb_ref = None
                tsb_boost = 1.0
                for tsb in tsb_lookup.get(component.name.lower(), []):
                    tsb_ref = tsb.get("id")
                    tsb_boost = 3.0  # TSB-related issues are 3x more likely
                    break
                
                # Also check for TSB matching the failure mode keywords
                for tsb in tsbs or []:
                    tsb_text = f"{tsb.get('title', '')} {tsb.get('description', '')}".lower()
                    if any(kw in tsb_text for kw in [mode_id, failure_mode.name.lower()]):
                        tsb_ref = tsb.get("id")
                        tsb_boost = max(tsb_boost, 2.5)
                
                fault_node = FaultNode(
                    id=node_id,
                    component=component,
                    failure_mode=failure_mode,
                    signature=signature,
                    prior_probability=0.05,  # Base 5% probability
                    tsb_reference=tsb_ref,
                    tsb_boost=tsb_boost,
                    diagnostic_test=failure_mode.diagnostic_approach,
                    repair_action=f"Repair or replace {component.name}",
                )
                tree.add_fault_node(fault_node)
        
        # Compute cascading effects based on connections
        self._compute_cascading_effects(tree)
        
        return tree
    
    def _build_tsb_lookup(self, tsbs: List[Dict]) -> Dict[str, List[Dict]]:
        """Build lookup from component names to relevant TSBs."""
        lookup = {}
        for tsb in tsbs:
            # Extract component references from TSB
            title = tsb.get("title", "").lower()
            desc = tsb.get("description", "").lower()
            components = tsb.get("components", [])
            
            for comp in components:
                comp_lower = comp.lower()
                if comp_lower not in lookup:
                    lookup[comp_lower] = []
                lookup[comp_lower].append(tsb)
        
        return lookup
    
    def _compute_cascading_effects(self, tree: FaultTree) -> None:
        """
        Compute which faults can cause other faults based on circuit topology.
        
        For example:
        - Blown fuse causes all downstream components to lose power
        - Relay failure causes controlled load to fail
        - Sensor failure may cause ECU to command wrong actuator state
        """
        # Build connection graph
        for node_id, node in tree.fault_nodes.items():
            component = node.component
            
            # Power supply components (fuses, relays) affect downstream
            if component.component_type in [ComponentType.FUSE, ComponentType.RELAY]:
                for downstream_id in component.connected_to:
                    if downstream_id in tree.components:
                        # Find all faults for downstream component
                        for other_node in tree.get_faults_for_component(downstream_id):
                            # This fault can cause downstream power loss
                            if "power" in other_node.failure_mode.id or "open" in other_node.failure_mode.id:
                                node.effects.append(other_node.id)
                                other_node.causes.append(node_id)
            
            # Sensors affect actuators through ECU
            if component.component_type == ComponentType.SENSOR:
                # Sensor failures can cause system malfunction
                for other_node in tree.fault_nodes.values():
                    if other_node.component.component_type in [
                        ComponentType.MOTOR, ComponentType.PUMP, 
                        ComponentType.VALVE, ComponentType.SOLENOID
                    ]:
                        # Sensor fault may cause wrong actuator command
                        if other_node.component.circuit_id == component.circuit_id:
                            node.effects.append(other_node.id)


class FaultTreeCache:
    """
    Cache for generated fault trees.
    
    Fault trees are expensive to generate (requires Mitchell queries),
    so we cache them based on vehicle + system.
    """
    
    def __init__(self, cache_dir: str = "/tmp/fault_tree_cache"):
        self.cache_dir = cache_dir
        import os
        os.makedirs(cache_dir, exist_ok=True)
    
    def _get_cache_key(
        self, 
        year: int, 
        make: str, 
        model: str, 
        engine: Optional[str],
        system: str
    ) -> str:
        """Generate cache key."""
        key_str = f"{year}_{make}_{model}_{engine or 'any'}_{system}"
        return hashlib.md5(key_str.encode()).hexdigest()
    
    def _get_cache_path(self, cache_key: str) -> str:
        """Get file path for cache entry."""
        import os
        return os.path.join(self.cache_dir, f"{cache_key}.json")
    
    def get(
        self,
        year: int,
        make: str,
        model: str,
        engine: Optional[str],
        system: str
    ) -> Optional[FaultTree]:
        """Get cached fault tree if available."""
        import os
        cache_key = self._get_cache_key(year, make, model, engine, system)
        cache_path = self._get_cache_path(cache_key)
        
        if os.path.exists(cache_path):
            try:
                with open(cache_path, 'r') as f:
                    data = json.load(f)
                tree = FaultTree.from_dict(data)
                tree.source = "cached"
                return tree
            except Exception:
                # Cache corrupted, return None
                return None
        return None
    
    def put(self, tree: FaultTree) -> None:
        """Cache a fault tree."""
        cache_key = self._get_cache_key(
            tree.vehicle_year,
            tree.vehicle_make,
            tree.vehicle_model,
            tree.vehicle_engine,
            tree.system
        )
        cache_path = self._get_cache_path(cache_key)
        
        with open(cache_path, 'w') as f:
            f.write(tree.to_json())
    
    def invalidate(
        self,
        year: int,
        make: str,
        model: str,
        engine: Optional[str],
        system: str
    ) -> None:
        """Remove cached fault tree."""
        import os
        cache_key = self._get_cache_key(year, make, model, engine, system)
        cache_path = self._get_cache_path(cache_key)
        
        if os.path.exists(cache_path):
            os.remove(cache_path)
